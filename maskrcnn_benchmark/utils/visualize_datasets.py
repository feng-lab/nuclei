#!/usr/bin/env python

# Copyright (c) 2017-present, Facebook, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
##############################################################################

import cv2
import numpy as np
import os
import sys
import random
import string

from torchvision.datasets.coco import CocoDetection
from maskrcnn_benchmark.config import cfg
import maskrcnn_benchmark.config.paths_catalog as path_catalog
import maskrcnn_benchmark.utils.cv2_util as cv2_util

import pycocotools.mask as mask_util

import imageio

import matplotlib
# Use a non-interactive backend
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon
from matplotlib.lines import Line2D

from . import colormap


plt.rcParams['pdf.fonttype'] = 42  # For editing in Adobe Illustrator


_GRAY = (218, 227, 218)
_GREEN = (18, 127, 15)
_WHITE = (255, 255, 255)


def convert_from_cls_format(cls_boxes, cls_segms):
    """Convert from the class boxes/segms/keyps format generated by the testing
    code.
    """
    box_list = [b for b in cls_boxes if len(b) > 0]
    if len(box_list) > 0:
        boxes = np.concatenate(box_list)
    else:
        boxes = None
    if cls_segms is not None:
        segms = [s for slist in cls_segms for s in slist]
    else:
        segms = None
    classes = []
    for j in range(len(cls_boxes)):
        classes += [j] * len(cls_boxes[j])
    return boxes, segms, classes


def get_class_string(class_index, score, class_index_to_name):
    class_text = class_index_to_name[class_index] if class_index_to_name is not None else \
        'id{:d}'.format(class_index)
    return class_text + ' {:0.2f}'.format(score).lstrip('0')


def vis_mask(img, mask, col, alpha=0.4, show_border=True, border_thick=1):
    """Visualizes a single binary mask."""

    img = img.astype(np.float32)
    idx = np.nonzero(mask)

    img[idx[0], idx[1], :] *= 1.0 - alpha
    img[idx[0], idx[1], :] += alpha * col

    if show_border:
        contours = cv2_util.findContours(
            mask.copy(), cv2.RETR_CCOMP, cv2.CHAIN_APPROX_NONE)[-2]
        cv2.drawContours(img, contours, -1, _WHITE, border_thick, cv2.LINE_AA)

    return img.astype(np.uint8)


def vis_class(img, pos, class_str, font_scale=0.35):
    """Visualizes the class."""
    img = img.astype(np.uint8)
    x0, y0 = int(pos[0]), int(pos[1])
    # Compute text size.
    txt = class_str
    font = cv2.FONT_HERSHEY_SIMPLEX
    ((txt_w, txt_h), _) = cv2.getTextSize(txt, font, font_scale, 1)
    # Place text background.
    back_tl = x0, y0 - int(1.3 * txt_h)
    back_br = x0 + txt_w, y0
    cv2.rectangle(img, back_tl, back_br, _GREEN, -1)
    # Show text.
    txt_tl = x0, y0 - int(0.3 * txt_h)
    cv2.putText(img, txt, txt_tl, font, font_scale, _GRAY, lineType=cv2.LINE_AA)
    return img


def vis_bbox(img, bbox, thick=1):
    """Visualizes a bounding box."""
    img = img.astype(np.uint8)
    (x0, y0, w, h) = bbox
    x1, y1 = int(x0 + w), int(y0 + h)
    x0, y0 = int(x0), int(y0)
    cv2.rectangle(img, (x0, y0), (x1, y1), _GREEN, thickness=thick)
    return img


def vis_one_image_opencv(
        im, boxes, segms=None, thresh=0.9,
        show_box=False, class_index_to_name=None, show_class=False):
    """Constructs a numpy array with the detections visualized."""

    if isinstance(boxes, list):
        boxes, segms, classes = convert_from_cls_format(
            boxes, segms)

    if boxes is None or boxes.shape[0] == 0 or max(boxes[:, 4]) < thresh:
        return im

    if segms is not None and len(segms) > 0:
        masks = mask_util.decode(segms)
        color_list = colormap()
        mask_color_id = 0

    # Display in largest to smallest order to reduce occlusion
    areas = (boxes[:, 2] - boxes[:, 0]) * (boxes[:, 3] - boxes[:, 1])
    sorted_inds = np.argsort(-areas)

    for i in sorted_inds:
        bbox = boxes[i, :4]
        score = boxes[i, -1]
        if score < thresh:
            continue

        # show box (off by default)
        if show_box:
            im = vis_bbox(
                im, (bbox[0], bbox[1], bbox[2] - bbox[0], bbox[3] - bbox[1]))

        # show class (off by default)
        if show_class:
            class_str = get_class_string(classes[i], score, class_index_to_name)
            im = vis_class(im, (bbox[0], bbox[1] - 2), class_str)

        # show mask
        if segms is not None and len(segms) > i:
            color_mask = color_list[mask_color_id % len(color_list), 0:3]
            mask_color_id += 1
            im = vis_mask(im, masks[..., i], color_mask)

    return im


def vis_one_image(
        im, im_name, output_dir, boxes, segms=None, thresh=0.9,
        dpi=200, box_alpha=0.3, class_index_to_name=None, show_class=False,
        ext='tif', out_when_no_box=False):
    """Visual debugging of detections."""
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    if isinstance(boxes, list):
        boxes, segms, classes = convert_from_cls_format(
            boxes, segms)

    if (boxes is None or boxes.shape[0] == 0) and not out_when_no_box:
        return
    if (boxes.shape[1] == 5 and max(boxes[:, 4]) < thresh) and not out_when_no_box:
        return

    if segms is not None and len(segms) > 0:
        masks = mask_util.decode(segms)

    color_list = colormap.colormap(rgb=True) / 255

    fig = plt.figure(frameon=False)
    fig.set_size_inches(im.shape[1] / dpi, im.shape[0] / dpi)
    ax = plt.Axes(fig, [0., 0., 1., 1.])
    ax.axis('off')
    fig.add_axes(ax)
    ax.imshow(im)

    if boxes is None:
        sorted_inds = [] # avoid crash when 'boxes' is None
    else:
        # Display in largest to smallest order to reduce occlusion
        areas = (boxes[:, 2] - boxes[:, 0]) * (boxes[:, 3] - boxes[:, 1])
        sorted_inds = np.argsort(-areas)

    mask_color_id = 0
    for i in sorted_inds:
        bbox = boxes[i, :4]
        score = boxes[i, -1] if boxes.shape[1] > 4 else 1.0
        if score < thresh:
            continue

        # show box (off by default)
        ax.add_patch(
            plt.Rectangle((bbox[0], bbox[1]),
                          bbox[2] - bbox[0],
                          bbox[3] - bbox[1],
                          fill=False, edgecolor='g',
                          linewidth=1, alpha=box_alpha))

        if show_class:
            ax.text(
                bbox[0], bbox[1] - 2,
                get_class_string(classes[i], score, class_index_to_name),
                fontsize=3,
                family='serif',
                bbox=dict(
                    facecolor='g', alpha=0.4, pad=0, edgecolor='none'),
                color='white')

        # show mask
        if segms is not None and len(segms) > i:
            img = np.ones(im.shape)
            color_mask = color_list[mask_color_id % len(color_list), 0:3]
            mask_color_id += 1

            w_ratio = .4
            for c in range(3):
                color_mask[c] = color_mask[c] * (1 - w_ratio) + w_ratio
            for c in range(3):
                img[:, :, c] = color_mask[c]
            e = masks[:, :, i]

            contour = cv2_util.findContours(
                e.copy(), cv2.RETR_CCOMP, cv2.CHAIN_APPROX_NONE)[-2]

            for c in contour:
                polygon = Polygon(
                    c.reshape((-1, 2)),
                    fill=True, facecolor=color_mask,
                    edgecolor='w', linewidth=0,
                    alpha=0.5, antialiased=False)
                ax.add_patch(polygon)

    output_name = os.path.basename(im_name) + '.' + ext
    fig.savefig(os.path.join(output_dir, '{}'.format(output_name)), dpi=dpi)
    plt.close('all')


def vis_one_training_image(
        im, im_name, output_dir, boxes, masks,
        box_alpha=0.3, ext='tif', is_box_xyxy=True):
    im_name += '_'
    im_name += ''.join(random.choices(string.ascii_uppercase + string.digits, k=5))

    cls_segms = [[] for _ in range(2)]
    cls_boxes = [[] for _ in range(2)]
    for idx, box in enumerate(boxes):
        cls_segms[1].append(mask_util.encode(np.array(masks[:, :, idx], dtype=np.uint8, order='F')))
        if is_box_xyxy:
            cls_boxes[1].append(box)
        else:
            cls_boxes[1].append(np.array([box[0],
                                          box[1],
                                          box[0] + box[2],
                                          box[1] + box[3]]))


    vis_one_image(
        im,
        im_name,
        output_dir=output_dir,
        boxes=cls_boxes,
        segms=cls_segms,
        class_index_to_name=None,
        box_alpha=box_alpha,
        show_class=False,
        thresh=0.0,
        ext=ext,
        out_when_no_box=False
    )


def vis_one_training_image_with_pred(
        im, im_name, output_dir, boxes,
        box_alpha=0.8, ext='tif', is_box_xyxy=True):
    cls_boxes = [[] for _ in range(2)]
    for idx, box in enumerate(boxes):
        if is_box_xyxy:
            cls_boxes[1].append(np.array([box[0],
                                          box[1],
                                          box[2],
                                          box[3]]))
        else:
            cls_boxes[1].append(np.array([box[0],
                                          box[1],
                                          box[0] + box[2],
                                          box[1] + box[3]]))


    vis_one_image(
        im,
        im_name,
        output_dir=output_dir,
        boxes=cls_boxes,
        segms=None,
        class_index_to_name=None,
        box_alpha=box_alpha,
        show_class=False,
        thresh=0.0,
        ext=ext,
        out_when_no_box=False
    )